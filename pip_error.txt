Collecting Flask (from -r requirements.txt (line 1))
  Using cached flask-3.1.0-py3-none-any.whl.metadata (2.7 kB)
  Using cached Flask-2.1.1-py3-none-any.whl.metadata (3.9 kB)
Collecting Flask-SQLAlchemy==2.5.1 (from -r requirements.txt (line 3))
  Using cached Flask_SQLAlchemy-2.5.1-py2.py3-none-any.whl.metadata (3.1 kB)
Collecting Flask-PyMongo==2.3.0 (from -r requirements.txt (line 4))
  Using cached Flask_PyMongo-2.3.0-py2.py3-none-any.whl.metadata (1.4 kB)
Collecting Flask-Mail==0.9.1 (from -r requirements.txt (line 5))
  Using cached Flask-Mail-0.9.1.tar.gz (45 kB)
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Collecting Flask-Login==0.5.0 (from -r requirements.txt (line 6))
  Using cached Flask_Login-0.5.0-py2.py3-none-any.whl.metadata (1.7 kB)
Collecting Flask-WTF==1.0.1 (from -r requirements.txt (line 7))
  Using cached Flask_WTF-1.0.1-py3-none-any.whl.metadata (1.9 kB)
Collecting WTForms==3.0.1 (from -r requirements.txt (line 8))
  Using cached WTForms-3.0.1-py3-none-any.whl.metadata (3.2 kB)
Collecting flask-cors==5.0.1 (from -r requirements.txt (line 9))
  Using cached flask_cors-5.0.1-py3-none-any.whl.metadata (961 bytes)
Collecting pandas==1.4.2 (from -r requirements.txt (line 10))
  Using cached pandas-1.4.2.tar.gz (4.9 MB)
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Getting requirements to build wheel: started
  Getting requirements to build wheel: finished with status 'done'
  Preparing metadata (pyproject.toml): started
  Preparing metadata (pyproject.toml): finished with status 'done'
Collecting scikit-learn==1.0.2 (from -r requirements.txt (line 11))
  Using cached scikit-learn-1.0.2.tar.gz (6.7 MB)
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Getting requirements to build wheel: started
  Getting requirements to build wheel: finished with status 'done'
  Preparing metadata (pyproject.toml): started
  Preparing metadata (pyproject.toml): finished with status 'error'
  error: subprocess-exited-with-error
  
  × Preparing metadata (pyproject.toml) did not run successfully.
  │ exit code: 1
  ╰─> [1793 lines of output]
      Partial import of sklearn during the build process.
      setup.py:128: DeprecationWarning:
      
        `numpy.distutils` is deprecated since NumPy 1.23.0, as a result
        of the deprecation of `distutils` itself. It will be removed for
        Python >= 3.12. For older Python versions it will remain present.
        It is recommended to use `setuptools < 60.0` for those Python versions.
        For more details, see:
          https://numpy.org/devdocs/reference/distutils_status_migration.html
      
      
        from numpy.distutils.command.build_ext import build_ext  # noqa
      INFO: C compiler: x86_64-linux-gnu-gcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -fPIC
      
      INFO: compile options: '-c'
      INFO: x86_64-linux-gnu-gcc: test_program.c
      INFO: x86_64-linux-gnu-gcc -pthread objects/test_program.o -o test_program
      INFO: C compiler: x86_64-linux-gnu-gcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -fPIC
      
      INFO: compile options: '-c'
      extra options: '-fopenmp'
      INFO: x86_64-linux-gnu-gcc: test_program.c
      INFO: x86_64-linux-gnu-gcc -pthread objects/test_program.o -o test_program -fopenmp
      Compiling sklearn/__check_build/_check_build.pyx because it changed.
      Compiling sklearn/preprocessing/_csr_polynomial_expansion.pyx because it changed.
      Compiling sklearn/cluster/_dbscan_inner.pyx because it changed.
      Compiling sklearn/cluster/_hierarchical_fast.pyx because it changed.
      Compiling sklearn/cluster/_k_means_common.pyx because it changed.
      Compiling sklearn/cluster/_k_means_lloyd.pyx because it changed.
      Compiling sklearn/cluster/_k_means_elkan.pyx because it changed.
      Compiling sklearn/cluster/_k_means_minibatch.pyx because it changed.
      Compiling sklearn/datasets/_svmlight_format_fast.pyx because it changed.
      Compiling sklearn/decomposition/_online_lda_fast.pyx because it changed.
      Compiling sklearn/decomposition/_cdnmf_fast.pyx because it changed.
      Compiling sklearn/ensemble/_gradient_boosting.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/_gradient_boosting.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/histogram.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/splitting.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/_binning.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/_predictor.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/_loss.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/_bitset.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/common.pyx because it changed.
      Compiling sklearn/ensemble/_hist_gradient_boosting/utils.pyx because it changed.
      Compiling sklearn/feature_extraction/_hashing_fast.pyx because it changed.
      Compiling sklearn/manifold/_utils.pyx because it changed.
      Compiling sklearn/manifold/_barnes_hut_tsne.pyx because it changed.
      Compiling sklearn/metrics/cluster/_expected_mutual_info_fast.pyx because it changed.
      Compiling sklearn/metrics/_pairwise_fast.pyx because it changed.
      Compiling sklearn/metrics/_dist_metrics.pyx because it changed.
      Compiling sklearn/neighbors/_ball_tree.pyx because it changed.
      Compiling sklearn/neighbors/_kd_tree.pyx because it changed.
      Compiling sklearn/neighbors/_partition_nodes.pyx because it changed.
      Compiling sklearn/neighbors/_quad_tree.pyx because it changed.
      Compiling sklearn/tree/_tree.pyx because it changed.
      Compiling sklearn/tree/_splitter.pyx because it changed.
      Compiling sklearn/tree/_criterion.pyx because it changed.
      Compiling sklearn/tree/_utils.pyx because it changed.
      Compiling sklearn/utils/sparsefuncs_fast.pyx because it changed.
      Compiling sklearn/utils/_cython_blas.pyx because it changed.
      Compiling sklearn/utils/arrayfuncs.pyx because it changed.
      Compiling sklearn/utils/murmurhash.pyx because it changed.
      Compiling sklearn/utils/_fast_dict.pyx because it changed.
      Compiling sklearn/utils/_openmp_helpers.pyx because it changed.
      Compiling sklearn/utils/_seq_dataset.pyx because it changed.
      Compiling sklearn/utils/_weight_vector.pyx because it changed.
      Compiling sklearn/utils/_random.pyx because it changed.
      Compiling sklearn/utils/_logistic_sigmoid.pyx because it changed.
      Compiling sklearn/utils/_readonly_array_wrapper.pyx because it changed.
      Compiling sklearn/utils/_typedefs.pyx because it changed.
      Compiling sklearn/svm/_newrand.pyx because it changed.
      Compiling sklearn/svm/_libsvm.pyx because it changed.
      Compiling sklearn/svm/_liblinear.pyx because it changed.
      Compiling sklearn/svm/_libsvm_sparse.pyx because it changed.
      Compiling sklearn/linear_model/_cd_fast.pyx because it changed.
      Compiling sklearn/linear_model/_sgd_fast.pyx because it changed.
      Compiling sklearn/linear_model/_sag_fast.pyx because it changed.
      Compiling sklearn/_isotonic.pyx because it changed.
      warning: sklearn/metrics/_dist_metrics.pxd:12:64: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:22:65: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:31:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:35:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:54:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:57:52: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:64:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:66:67: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/cluster/_k_means_common.pyx:27:5: Exception check on '_euclidean_dense_dense' will always require the GIL to be acquired. Declare '_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/cluster/_k_means_common.pyx:59:5: Exception check on '_euclidean_sparse_dense' will always require the GIL to be acquired. Declare '_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/cluster/_k_means_common.pyx:116:40: Exception check after calling '__pyx_fuse_0_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_common.pyx:116:40: Exception check after calling '__pyx_fuse_1_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_common.pyx:150:41: Exception check after calling '__pyx_fuse_0_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_common.pyx:150:41: Exception check after calling '__pyx_fuse_1_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:334:5: Exception check on '_update_chunk_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_update_chunk_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_update_chunk_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:569:5: Exception check on '_update_chunk_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_update_chunk_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_update_chunk_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:86:41: Exception check after calling '__pyx_fuse_0_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:91:45: Exception check after calling '__pyx_fuse_0_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:86:41: Exception check after calling '__pyx_fuse_1_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:91:45: Exception check after calling '__pyx_fuse_1_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:162:42: Exception check after calling '__pyx_fuse_0_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:170:46: Exception check after calling '__pyx_fuse_0_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:162:42: Exception check after calling '__pyx_fuse_1_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:170:46: Exception check after calling '__pyx_fuse_1_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:292:31: Exception check after calling '__pyx_fuse_0_update_chunk_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_update_chunk_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_update_chunk_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:292:31: Exception check after calling '__pyx_fuse_1_update_chunk_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_update_chunk_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_update_chunk_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:380:60: Exception check after calling '__pyx_fuse_0_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:391:57: Exception check after calling '__pyx_fuse_0_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:380:60: Exception check after calling '__pyx_fuse_1_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:391:57: Exception check after calling '__pyx_fuse_1_euclidean_dense_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_dense_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:523:32: Exception check after calling '__pyx_fuse_0_update_chunk_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_update_chunk_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_update_chunk_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:523:32: Exception check after calling '__pyx_fuse_1_update_chunk_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_update_chunk_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_update_chunk_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:619:61: Exception check after calling '__pyx_fuse_0_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:631:58: Exception check after calling '__pyx_fuse_0_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:619:61: Exception check after calling '__pyx_fuse_1_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_elkan.pyx:631:58: Exception check after calling '__pyx_fuse_1_euclidean_sparse_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_euclidean_sparse_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:162:5: Exception check on '_update_chunk_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_update_chunk_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_update_chunk_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:356:5: Exception check on '_update_chunk_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_update_chunk_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_update_chunk_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:129:31: Exception check after calling '__pyx_fuse_0_update_chunk_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_update_chunk_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_update_chunk_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:129:31: Exception check after calling '__pyx_fuse_1_update_chunk_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_update_chunk_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_update_chunk_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:196:9: Exception check after calling '__pyx_fuse_0_gemm' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_gemm' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_gemm' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:196:9: Exception check after calling '__pyx_fuse_1_gemm' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_gemm' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_gemm' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:322:32: Exception check after calling '__pyx_fuse_0_update_chunk_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_update_chunk_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_update_chunk_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_lloyd.pyx:322:32: Exception check after calling '__pyx_fuse_1_update_chunk_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_update_chunk_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_update_chunk_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_minibatch.pyx:67:5: Exception check on 'update_center_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'update_center_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'update_center_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_minibatch.pyx:175:5: Exception check on 'update_center_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'update_center_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'update_center_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_minibatch.pyx:60:31: Exception check after calling '__pyx_fuse_0update_center_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0update_center_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0update_center_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_minibatch.pyx:60:31: Exception check after calling '__pyx_fuse_1update_center_dense' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1update_center_dense' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1update_center_dense' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_minibatch.pyx:168:32: Exception check after calling '__pyx_fuse_0update_center_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0update_center_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0update_center_sparse' to allow an error code to be returned.
      performance hint: sklearn/cluster/_k_means_minibatch.pyx:168:32: Exception check after calling '__pyx_fuse_1update_center_sparse' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1update_center_sparse' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1update_center_sparse' to allow an error code to be returned.
      warning: sklearn/tree/_tree.pxd:61:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:62:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:63:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:84:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:89:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:58:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:59:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:60:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:49:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:87:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:119:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:137:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:139:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:160:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:161:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_bitset.pyx:15:5: Exception check on 'init_bitset' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'init_bitset' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'init_bitset' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_bitset.pyx:23:5: Exception check on 'set_bitset' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'set_bitset' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'set_bitset' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_bitset.pxd:10:28: No exception value declared for 'in_bitset' in pxd file.
      Users cimporting this function and calling it without the gil will always require an exception check.
      Suggest adding an explicit exception value.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_bitset.pxd:12:40: No exception value declared for 'in_bitset_memoryview' in pxd file.
      Users cimporting this function and calling it without the gil will always require an exception check.
      Suggest adding an explicit exception value.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_bitset.pxd:15:42: No exception value declared for 'in_bitset_2d_memoryview' in pxd file.
      Users cimporting this function and calling it without the gil will always require an exception check.
      Suggest adding an explicit exception value.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_loss.pyx:193:5: Exception check on '_compute_softmax' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_compute_softmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_compute_softmax' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_loss.pyx:173:28: Exception check after calling '_compute_softmax' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_compute_softmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_compute_softmax' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_loss.pyx:184:28: Exception check after calling '_compute_softmax' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_compute_softmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_compute_softmax' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_predictor.pyx:69:38: Exception check after calling 'in_bitset_2d_memoryview' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'in_bitset_2d_memoryview' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_predictor.pyx:74:40: Exception check after calling 'in_bitset_2d_memoryview' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'in_bitset_2d_memoryview' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/_predictor.pyx:135:38: Exception check after calling 'in_bitset_2d_memoryview' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'in_bitset_2d_memoryview' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:257:6: Exception check on '_build_histogram_naive' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_naive' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_naive' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:281:6: Exception check on '_subtract_histograms' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_subtract_histograms' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_subtract_histograms' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:305:6: Exception check on '_build_histogram' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:352:6: Exception check on '_build_histogram_no_hessian' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_no_hessian' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_no_hessian' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:396:6: Exception check on '_build_histogram_root' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_root' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_root' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:449:6: Exception check on '_build_histogram_root_no_hessian' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_root_no_hessian' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_root_no_hessian' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:161:60: Exception check after calling '_compute_histogram_brute_single_feature' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_compute_histogram_brute_single_feature' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_compute_histogram_brute_single_feature' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:193:48: Exception check after calling '_build_histogram_root_no_hessian' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_root_no_hessian' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_root_no_hessian' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:197:37: Exception check after calling '_build_histogram_root' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_root' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_root' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:202:43: Exception check after calling '_build_histogram_no_hessian' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram_no_hessian' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram_no_hessian' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:206:32: Exception check after calling '_build_histogram' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_build_histogram' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_build_histogram' to allow an error code to be returned.
      performance hint: sklearn/ensemble/_hist_gradient_boosting/histogram.pyx:249:32: Exception check after calling '_subtract_histograms' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_subtract_histograms' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_subtract_histograms' to allow an error code to be returned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              if n_used_bins <= 1:
                  free(cat_infos)
                  return
      
              qsort(cat_infos, n_used_bins, sizeof(categorical_info),
                    compare_cat_infos)
                    ^
      ------------------------------------------------------------
      
      sklearn/ensemble/_hist_gradient_boosting/splitting.pyx:920:14: Cannot assign type 'int (const void *, const void *) except? -1 nogil' to 'int (*)(const void *, const void *) noexcept nogil'. Exception values are incompatible. Suggest adding 'noexcept' to the type of 'compare_cat_infos'.
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/ensemble/_hist_gradient_boosting/splitting.pyx
      performance hint: sklearn/linear_model/_cd_fast.pyx:46:5: Exception check on 'fmax' will always require the GIL to be acquired. Declare 'fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:52:5: Exception check on 'fsign' will always require the GIL to be acquired. Declare 'fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:61:5: Exception check on 'abs_max' will always require the GIL to be acquired. Declare 'abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:73:5: Exception check on 'max' will always require the GIL to be acquired. Declare 'max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:85:5: Exception check on 'diff_abs_max' will always require the GIL to be acquired. Declare 'diff_abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:154:13: Exception check after calling '__pyx_fuse_0_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:155:13: Exception check after calling '__pyx_fuse_0_gemv' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_gemv' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_gemv' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:159:19: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:177:25: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:180:26: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:185:34: Exception check after calling '__pyx_fuse_0fsign' will always require the GIL to be acquired. Declare '__pyx_fuse_0fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:185:46: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:190:25: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:194:30: Exception check after calling '__pyx_fuse_0fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_0fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:196:28: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:206:21: Exception check after calling '__pyx_fuse_0_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:207:21: Exception check after calling '__pyx_fuse_0_gemv' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_gemv' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_gemv' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:213:39: Exception check after calling '__pyx_fuse_0max' will always require the GIL to be acquired. Declare '__pyx_fuse_0max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:215:43: Exception check after calling '__pyx_fuse_0abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_0abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:218:30: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:221:30: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:231:31: Exception check after calling '__pyx_fuse_0_asum' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:235:38: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:154:13: Exception check after calling '__pyx_fuse_1_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:155:13: Exception check after calling '__pyx_fuse_1_gemv' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_gemv' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_gemv' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:159:19: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:177:25: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:180:26: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:185:34: Exception check after calling '__pyx_fuse_1fsign' will always require the GIL to be acquired. Declare '__pyx_fuse_1fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:185:46: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:190:25: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:194:30: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:196:28: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:206:21: Exception check after calling '__pyx_fuse_1_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:207:21: Exception check after calling '__pyx_fuse_1_gemv' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_gemv' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_gemv' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:213:39: Exception check after calling '__pyx_fuse_1max' will always require the GIL to be acquired. Declare '__pyx_fuse_1max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:215:43: Exception check after calling '__pyx_fuse_1abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_1abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:218:30: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:221:30: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:231:31: Exception check after calling '__pyx_fuse_1_asum' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:235:38: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:353:19: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:396:33: Exception check after calling '__pyx_fuse_0fsign' will always require the GIL to be acquired. Declare '__pyx_fuse_0fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:396:45: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:437:39: Exception check after calling '__pyx_fuse_0max' will always require the GIL to be acquired. Declare '__pyx_fuse_0max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:439:43: Exception check after calling '__pyx_fuse_0abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_0abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:442:30: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:445:30: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:454:31: Exception check after calling '__pyx_fuse_0_asum' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:456:54: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:353:19: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:396:33: Exception check after calling '__pyx_fuse_1fsign' will always require the GIL to be acquired. Declare '__pyx_fuse_1fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:396:45: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:437:39: Exception check after calling '__pyx_fuse_1max' will always require the GIL to be acquired. Declare '__pyx_fuse_1max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:439:43: Exception check after calling '__pyx_fuse_1abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_1abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:442:30: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:445:30: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:454:31: Exception check after calling '__pyx_fuse_1_asum' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:456:54: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:555:25: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:563:33: Exception check after calling '__pyx_fuse_0fsign' will always require the GIL to be acquired. Declare '__pyx_fuse_0fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:563:45: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:568:25: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:585:30: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:590:39: Exception check after calling '__pyx_fuse_0max' will always require the GIL to be acquired. Declare '__pyx_fuse_0max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:592:43: Exception check after calling '__pyx_fuse_0abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_0abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:601:30: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:612:37: Exception check after calling '__pyx_fuse_0_asum' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:555:25: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:563:33: Exception check after calling '__pyx_fuse_1fsign' will always require the GIL to be acquired. Declare '__pyx_fuse_1fsign' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:563:45: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:568:25: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:585:30: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:590:39: Exception check after calling '__pyx_fuse_1max' will always require the GIL to be acquired. Declare '__pyx_fuse_1max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:592:43: Exception check after calling '__pyx_fuse_1abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_1abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:601:30: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:612:37: Exception check after calling '__pyx_fuse_1_asum' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:694:35: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:697:13: Exception check after calling '__pyx_fuse_0_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:701:25: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:705:25: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:720:21: Exception check after calling '__pyx_fuse_0_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:732:29: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:742:34: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:746:26: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:749:21: Exception check after calling '__pyx_fuse_0_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:750:35: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:750:21: Exception check after calling '__pyx_fuse_0_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_scal' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:763:29: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:767:37: Exception check after calling '__pyx_fuse_0diff_abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_0diff_abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:772:38: Exception check after calling '__pyx_fuse_0abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_0abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:784:42: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:792:41: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:799:30: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:800:30: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:810:29: Exception check after calling '__pyx_fuse_0_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:815:37: Exception check after calling '__pyx_fuse_0_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:694:35: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:697:13: Exception check after calling '__pyx_fuse_1_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:701:25: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:705:25: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:720:21: Exception check after calling '__pyx_fuse_1_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:732:29: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:742:34: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:746:26: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:749:21: Exception check after calling '__pyx_fuse_1_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_copy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:750:35: Exception check after calling '__pyx_fuse_1fmax' will always require the GIL to be acquired. Declare '__pyx_fuse_1fmax' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:750:21: Exception check after calling '__pyx_fuse_1_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_scal' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:763:29: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_cd_fast.pyx:767:37: Exception check after calling '__pyx_fuse_1diff_abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_1diff_abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:772:38: Exception check after calling '__pyx_fuse_1abs_max' will always require the GIL to be acquired. Declare '__pyx_fuse_1abs_max' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_cd_fast.pyx:784:42: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:792:41: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:799:30: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:800:30: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:810:29: Exception check after calling '__pyx_fuse_1_dot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_cd_fast.pyx:815:37: Exception check after calling '__pyx_fuse_1_nrm2' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/linear_model/_sag_fast.pyx:1198:5: Exception check on 'predict_sample64' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'predict_sample64' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'predict_sample64' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:1245:5: Exception check on 'predict_sample32' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'predict_sample32' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'predict_sample32' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:463:43: Exception check after calling 'random' will always require the GIL to be acquired. Declare 'random' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sag_fast.pyx:491:32: Exception check after calling 'predict_sample64' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'predict_sample64' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'predict_sample64' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:496:35: Exception check after calling 'dloss' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'dloss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'dloss' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:499:44: Exception check after calling 'dloss' will always require the GIL to be acquired. Declare 'dloss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sag_fast.pyx:794:43: Exception check after calling 'random' will always require the GIL to be acquired. Declare 'random' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sag_fast.pyx:822:32: Exception check after calling 'predict_sample32' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'predict_sample32' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'predict_sample32' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:827:35: Exception check after calling 'dloss' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'dloss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'dloss' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:830:44: Exception check after calling 'dloss' will always require the GIL to be acquired. Declare 'dloss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sag_fast.pyx:1333:24: Exception check after calling 'next' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'next' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'next' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:1337:28: Exception check after calling 'predict_sample64' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'predict_sample64' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'predict_sample64' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:1341:27: Exception check after calling 'dloss' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'dloss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'dloss' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sag_fast.pyx:1344:39: Exception check after calling '_loss' will always require the GIL to be acquired. Declare '_loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:704:5: Exception check on 'l1penalty' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'l1penalty' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'l1penalty' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:547:31: Exception check after calling 'shuffle' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'shuffle' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'shuffle' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:549:28: Exception check after calling 'next' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'next' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'next' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:557:25: Exception check after calling 'dot' will always require the GIL to be acquired. Declare 'dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:564:40: Exception check after calling 'loss' will always require the GIL to be acquired. Declare 'loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:575:45: Exception check after calling 'loss' will always require the GIL to be acquired. Declare 'loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:578:38: Exception check after calling 'loss' will always require the GIL to be acquired. Declare 'loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:580:38: Exception check after calling 'dloss' will always require the GIL to be acquired. Declare 'dloss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:602:27: Exception check after calling 'scale' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'scale' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'scale' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:605:25: Exception check after calling 'add' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'add' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'add' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:618:33: Exception check after calling 'add_average' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'add_average' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'add_average' to allow an error code to be returned.
      performance hint: sklearn/linear_model/_sgd_fast.pyx:625:29: Exception check after calling 'l1penalty' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'l1penalty' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'l1penalty' to allow an error code to be returned.
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/manifold/_barnes_hut_tsne.pyx:220:30: Exception check after calling 'summarize' will always require the GIL to be acquired. Declare 'summarize' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      warning: sklearn/metrics/_dist_metrics.pxd:12:64: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:22:65: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:31:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:35:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:54:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:57:52: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:64:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:66:67: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:295:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:303:52: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:334:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:338:67: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:433:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:437:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:440:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:443:74: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:472:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:481:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:484:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:487:74: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:510:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:543:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:573:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:581:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:584:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:587:74: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:631:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:639:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:642:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:645:74: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:694:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:710:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:713:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:716:74: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:739:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:761:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:784:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:810:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:840:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:864:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:889:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:914:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:938:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:962:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:986:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:1020:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:1026:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:1029:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:1032:74: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pyx:1132:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:562:66: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:570:49: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:632:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:1122:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:1131:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:1716:78: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_ball_tree.pyx:104:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_ball_tree.pyx:120:82: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_ball_tree.pyx:131:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:12:64: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:22:65: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:31:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:35:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:54:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:57:52: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:64:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:66:67: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/neighbors/_binary_tree.pxi:506:5: Exception check on 'dual_swap' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'dual_swap' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'dual_swap' to allow an error code to be returned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              # determine number of levels in the tree, and from this
              # the number of nodes in the tree.  This results in leaf nodes
              # with numbers of points between leaf_size and 2 * leaf_size
              self.n_levels = int(
                  np.log2(fmax(1, (n_samples - 1) / self.leaf_size)) + 1)
              self.n_nodes = (2 ** self.n_levels) - 1
                                                  ^
      ------------------------------------------------------------
      
      sklearn/neighbors/_binary_tree.pxi:982:44: Cannot assign type 'double' to 'ITYPE_t' (alias of 'Py_ssize_t')
      warning: sklearn/neighbors/_binary_tree.pxi:1161:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1162:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1286:17: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1418:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1723:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1771:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1772:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1825:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1826:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1921:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1922:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1924:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1925:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2007:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2008:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2094:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2098:28: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2099:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2100:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2256:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2257:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2262:28: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2263:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2377:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2378:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2427:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2428:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2429:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2430:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_ball_tree.pyx:56:9: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_ball_tree.pyx:57:9: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_ball_tree.pyx:58:9: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_ball_tree.pyx:64:24: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/neighbors/_ball_tree.pyx
      warning: sklearn/neighbors/_binary_tree.pxi:562:66: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:570:49: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:632:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:1122:58: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:1131:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_binary_tree.pxi:1716:78: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_kd_tree.pyx:86:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_kd_tree.pyx:147:82: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:12:64: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:22:65: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:31:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:35:79: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:54:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:57:52: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:64:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/metrics/_dist_metrics.pxd:66:67: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/neighbors/_binary_tree.pxi:506:5: Exception check on 'dual_swap' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'dual_swap' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'dual_swap' to allow an error code to be returned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              # determine number of levels in the tree, and from this
              # the number of nodes in the tree.  This results in leaf nodes
              # with numbers of points between leaf_size and 2 * leaf_size
              self.n_levels = int(
                  np.log2(fmax(1, (n_samples - 1) / self.leaf_size)) + 1)
              self.n_nodes = (2 ** self.n_levels) - 1
                                                  ^
      ------------------------------------------------------------
      
      sklearn/neighbors/_binary_tree.pxi:982:44: Cannot assign type 'double' to 'ITYPE_t' (alias of 'Py_ssize_t')
      warning: sklearn/neighbors/_binary_tree.pxi:1161:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1162:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1286:17: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1418:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1723:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1771:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1772:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1825:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1826:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1921:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1922:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1924:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:1925:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2007:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2008:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2094:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2098:28: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2099:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2100:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2256:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2257:13: Assigning to 'NodeData_t *' from 'const NodeData_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2262:28: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2263:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2377:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2378:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2427:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2428:13: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2429:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_binary_tree.pxi:2430:13: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_kd_tree.pyx:47:9: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_kd_tree.pyx:48:9: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_kd_tree.pyx:49:9: Assigning to 'DTYPE_t *' from 'const DTYPE_t *' discards const qualifier
      warning: sklearn/neighbors/_kd_tree.pyx:50:9: Assigning to 'ITYPE_t *' from 'const ITYPE_t *' discards const qualifier
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/neighbors/_kd_tree.pyx
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pyx:116:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pyx:305:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pyx:464:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pyx:559:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pyx:571:70: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:49:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:87:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:119:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:137:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:139:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:160:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:161:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:61:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:62:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:63:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:84:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:89:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:58:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:59:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:60:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
          def __cinit__(self, int n_dimensions, int verbose):
              """Constructor."""
              # Parameters of the tree
              self.n_dimensions = n_dimensions
              self.verbose = verbose
              self.n_cells_per_cell = 2 ** self.n_dimensions
                                        ^
      ------------------------------------------------------------
      
      sklearn/neighbors/_quad_tree.pyx:56:34: Cannot assign type 'double' to 'SIZE_t' (alias of 'Py_ssize_t')
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/neighbors/_quad_tree.pyx
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              free_problem(problem)
              free_parameter(param)
              raise ValueError(error_msg)
      
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_liblinear.pyx:55:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              free_parameter(param)
              raise ValueError(error_msg)
      
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
          blas_functions.axpy = _axpy[double]
                                     ^
      ------------------------------------------------------------
      
      sklearn/svm/_liblinear.pyx:56:31: Cannot assign type 'void (int, double, double *, int, double *, int) except * nogil' to 'axpy_func' (alias of 'void (*)(int, double, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              raise ValueError(error_msg)
      
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
          blas_functions.axpy = _axpy[double]
          blas_functions.scal = _scal[double]
                                     ^
      ------------------------------------------------------------
      
      sklearn/svm/_liblinear.pyx:57:31: Cannot assign type 'void (int, double, double *, int) except * nogil' to 'scal_func' (alias of 'void (*)(int, double, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
      
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
          blas_functions.axpy = _axpy[double]
          blas_functions.scal = _scal[double]
          blas_functions.nrm2 = _nrm2[double]
                                     ^
      ------------------------------------------------------------
      
      sklearn/svm/_liblinear.pyx:58:31: Cannot assign type 'double (int, double *, int) except * nogil' to 'nrm2_func' (alias of 'double (*)(int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/svm/_liblinear.pyx
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
          if error_msg:
              # for SVR: epsilon is called p in libsvm
              error_repl = error_msg.decode('utf-8').replace("p < 0", "epsilon < 0")
              raise ValueError(error_repl)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm.pyx:191:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
                             class_weight_label.data, class_weight.data)
          model = set_model(&param, <int> nSV.shape[0], SV.data, SV.shape,
                            support.data, support.shape, sv_coef.strides,
                            sv_coef.data, intercept.data, nSV.data, probA.data, probB.data)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm.pyx:355:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
                            sv_coef.data, intercept.data, nSV.data,
                            probA.data, probB.data)
      
          cdef np.npy_intp n_class = get_nr(model)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm.pyx:461:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              n_class = 1
          else:
              n_class = get_nr(model)
              n_class = n_class * (n_class - 1) // 2
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm.pyx:567:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
          if error_msg:
              raise ValueError(error_msg)
      
          cdef np.ndarray[np.float64_t, ndim=1, mode='c'] target
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm.pyx:711:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/svm/_libsvm.pyx
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
          if error_msg:
              free_problem(problem)
              free_param(param)
              raise ValueError(error_msg)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm_sparse.pyx:153:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
                                sv_coef.data, intercept.data,
                                nSV.data, probA.data, probB.data)
          #TODO: use check_model
          dec_values = np.empty(T_indptr.shape[0]-1)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm_sparse.pyx:284:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
          #TODO: use check_model
          cdef np.npy_intp n_class = get_nr(model)
          cdef int rv
          dec_values = np.empty((T_indptr.shape[0]-1, n_class), dtype=np.float64)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm_sparse.pyx:343:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              n_class = get_nr(model)
              n_class = n_class * (n_class - 1) // 2
      
          dec_values = np.empty((T_indptr.shape[0] - 1, n_class), dtype=np.float64)
          cdef BlasFunctions blas_functions
          blas_functions.dot = _dot[double]
                                   ^
      ------------------------------------------------------------
      
      sklearn/svm/_libsvm_sparse.pyx:412:29: Cannot assign type 'double (int, double *, int, double *, int) except * nogil' to 'dot_func' (alias of 'double (*)(int, double *, int, double *, int) noexcept'). Exception values are incompatible. Suggest adding 'noexcept' to the type of the value being assigned.
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/svm/_libsvm_sparse.pyx
      warning: sklearn/tree/_criterion.pxd:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:58:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:59:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:60:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:61:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:62:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:63:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:84:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:89:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:82:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:89:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:96:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:278:76: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:344:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:371:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:398:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:740:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:784:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:795:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:806:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:1028:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:1078:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:1109:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pyx:1137:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:49:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:87:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:119:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:137:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:139:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:160:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:161:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/tree/_criterion.pyx:165:30: Exception check after calling 'children_impurity' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'children_impurity' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'children_impurity' to allow an error code to be returned.
      performance hint: sklearn/tree/_criterion.pyx:536:44: Exception check after calling 'log' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'log' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_criterion.pyx:570:49: Exception check after calling 'log' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'log' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_criterion.pyx:575:50: Exception check after calling 'log' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'log' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_criterion.pyx:1072:89: Exception check after calling 'get_median' will always require the GIL to be acquired. Declare 'get_median' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1100:74: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1102:62: Exception check after calling 'pop' will always require the GIL to be acquired. Declare 'pop' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1128:75: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1130:63: Exception check after calling 'pop' will always require the GIL to be acquired. Declare 'pop' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1168:70: Exception check after calling 'remove' will always require the GIL to be acquired. Declare 'remove' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1184:69: Exception check after calling 'remove' will always require the GIL to be acquired. Declare 'remove' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1248:74: Exception check after calling 'get_median' will always require the GIL to be acquired. Declare 'get_median' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1260:75: Exception check after calling 'get_median' will always require the GIL to be acquired. Declare 'get_median' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1361:32: Exception check after calling 'poisson_loss' will always require the GIL to be acquired. Declare 'poisson_loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1396:56: Exception check after calling 'log' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'log' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_criterion.pyx:1397:58: Exception check after calling 'log' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'log' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_criterion.pyx:1418:44: Exception check after calling 'poisson_loss' will always require the GIL to be acquired. Declare 'poisson_loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_criterion.pyx:1421:45: Exception check after calling 'poisson_loss' will always require the GIL to be acquired. Declare 'poisson_loss' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      warning: sklearn/tree/_splitter.pxd:84:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:89:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:58:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:59:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:60:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:61:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:62:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:63:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pyx:180:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pyx:210:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pyx:264:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pyx:578:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pyx:1096:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pyx:1326:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:49:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:87:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:119:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:137:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:139:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:160:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:161:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/tree/_splitter.pyx:42:5: Exception check on '_init_split' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_init_split' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_init_split' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:456:5: Exception check on 'sort' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'sort' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'sort' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:463:5: Exception check on 'swap' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'swap' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'swap' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:492:5: Exception check on 'introsort' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'introsort' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'introsort' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:525:5: Exception check on 'sift_down' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'sift_down' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'sift_down' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:548:5: Exception check on 'heapsort' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'heapsort' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'heapsort' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:940:5: Exception check on 'binary_search' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'binary_search' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'binary_search' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:965:5: Exception check on 'extract_nnz_index_to_samples' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'extract_nnz_index_to_samples' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'extract_nnz_index_to_samples' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:1005:5: Exception check on 'extract_nnz_binary_search' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'extract_nnz_binary_search' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'extract_nnz_binary_search' to allow an error code to be returned.
      performance hint: sklearn/tree/_splitter.pyx:1077:5: Exception check on 'sparse_swap' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'sparse_swap' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'sparse_swap' to allow an error code to be returned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
          if not is_samples_sorted[0]:
              n_samples = end - start
              memcpy(sorted_samples + start, samples + start,
                     n_samples * sizeof(SIZE_t))
              qsort(sorted_samples + start, n_samples, sizeof(SIZE_t),
                    compare_SIZE_t)
                    ^
      ------------------------------------------------------------
      
      sklearn/tree/_splitter.pyx:1033:14: Cannot assign type 'int (const void *, const void *) except? -1 nogil' to 'int (*)(const void *, const void *) noexcept nogil'. Exception values are incompatible. Suggest adding 'noexcept' to the type of 'compare_SIZE_t'.
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/tree/_splitter.pyx
      warning: sklearn/tree/_tree.pxd:61:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:62:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:63:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:84:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:89:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:58:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:59:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:60:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pyx:267:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pyx:414:76: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pyx:668:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pyx:680:70: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pyx:714:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:49:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:87:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:119:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:137:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:139:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:160:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:161:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
      
              # Initial capacity
              cdef int init_capacity
      
              if tree.max_depth <= 10:
                  init_capacity = (2 ** (tree.max_depth + 1)) - 1
                                                              ^
      ------------------------------------------------------------
      
      sklearn/tree/_tree.pyx:146:56: Cannot assign type 'double' to 'int'
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/tree/_tree.pyx
      warning: sklearn/tree/_utils.pxd:49:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:87:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:119:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:137:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:139:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:160:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pxd:161:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:61:73: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:62:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_tree.pxd:63:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:84:72: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_splitter.pxd:89:68: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:57:45: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:58:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:59:48: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_criterion.pxd:60:57: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:72:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:91:51: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:94:59: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:95:63: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/neighbors/_quad_tree.pxd:96:80: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:25:75: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:110:61: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:226:56: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:314:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:331:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:489:40: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      warning: sklearn/tree/_utils.pyx:503:71: The keyword 'nogil' should appear at the end of the function signature line. Placing it before 'except' or 'noexcept' will be disallowed in a future version of Cython.
      performance hint: sklearn/tree/_utils.pyx:25:5: Exception check on 'safe_realloc' will always require the GIL to be acquired. Declare 'safe_realloc' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pxd:55:20: No exception value declared for 'rand_int' in pxd file.
      Users cimporting this function and calling it without the gil will always require an exception check.
      Suggest adding an explicit exception value.
      performance hint: sklearn/tree/_utils.pxd:59:24: No exception value declared for 'rand_uniform' in pxd file.
      Users cimporting this function and calling it without the gil will always require an exception check.
      Suggest adding an explicit exception value.
      performance hint: sklearn/tree/_utils.pxd:63:15: No exception value declared for 'log' in pxd file.
      Users cimporting this function and calling it without the gil will always require an exception check.
      Suggest adding an explicit exception value.
      performance hint: sklearn/tree/_utils.pyx:123:24: Exception check after calling '__pyx_fuse_9safe_realloc' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_9safe_realloc' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_utils.pyx:201:27: Exception check after calling 'heapify_up' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'heapify_up' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'heapify_up' to allow an error code to be returned.
      performance hint: sklearn/tree/_utils.pyx:221:29: Exception check after calling 'heapify_down' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'heapify_down' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'heapify_down' to allow an error code to be returned.
      performance hint: sklearn/tree/_utils.pyx:239:24: Exception check after calling '__pyx_fuse_10safe_realloc' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_10safe_realloc' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_utils.pyx:255:23: Exception check after calling 'heapify_up' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'heapify_up' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'heapify_up' to allow an error code to be returned.
      performance hint: sklearn/tree/_utils.pyx:277:29: Exception check after calling 'heapify_down' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'heapify_down' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'heapify_down' to allow an error code to be returned.
      performance hint: sklearn/tree/_utils.pyx:322:20: Exception check after calling '__pyx_fuse_3safe_realloc' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_3safe_realloc' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_utils.pyx:345:24: Exception check after calling '__pyx_fuse_3safe_realloc' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_3safe_realloc' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Declare any exception value explicitly for functions in pxd files.
      performance hint: sklearn/tree/_utils.pyx:487:32: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:512:20: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:513:45: Exception check after calling 'get_median' will always require the GIL to be acquired. Declare 'get_median' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:516:47: Exception check after calling 'update_median_parameters_post_push' will always require the GIL to be acquired. Declare 'update_median_parameters_post_push' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:527:20: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:547:69: Exception check after calling 'get_weight_from_index' will always require the GIL to be acquired. Declare 'get_weight_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:550:68: Exception check after calling 'get_weight_from_index' will always require the GIL to be acquired. Declare 'get_weight_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:556:44: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:559:68: Exception check after calling 'get_weight_from_index' will always require the GIL to be acquired. Declare 'get_weight_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:569:20: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:570:45: Exception check after calling 'get_median' will always require the GIL to be acquired. Declare 'get_median' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:572:42: Exception check after calling 'remove' will always require the GIL to be acquired. Declare 'remove' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:573:49: Exception check after calling 'update_median_parameters_post_remove' will always require the GIL to be acquired. Declare 'update_median_parameters_post_remove' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:584:20: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:585:45: Exception check after calling 'get_median' will always require the GIL to be acquired. Declare 'get_median' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:588:28: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:591:39: Exception check after calling 'pop' will always require the GIL to be acquired. Declare 'pop' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:592:49: Exception check after calling 'update_median_parameters_post_remove' will always require the GIL to be acquired. Declare 'update_median_parameters_post_remove' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:603:28: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:610:28: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:631:44: Exception check after calling 'size' will always require the GIL to be acquired. Declare 'size' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:634:68: Exception check after calling 'get_weight_from_index' will always require the GIL to be acquired. Declare 'get_weight_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:641:69: Exception check after calling 'get_weight_from_index' will always require the GIL to be acquired. Declare 'get_weight_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:644:68: Exception check after calling 'get_weight_from_index' will always require the GIL to be acquired. Declare 'get_weight_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:652:53: Exception check after calling 'get_value_from_index' will always require the GIL to be acquired. Declare 'get_value_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:653:53: Exception check after calling 'get_value_from_index' will always require the GIL to be acquired. Declare 'get_value_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/tree/_utils.pyx:656:52: Exception check after calling 'get_value_from_index' will always require the GIL to be acquired. Declare 'get_value_from_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_cython_blas.pyx:20:5: Exception check on '_dot' will always require the GIL to be acquired. Declare '_dot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_cython_blas.pyx:33:5: Exception check on '_asum' will always require the GIL to be acquired. Declare '_asum' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_cython_blas.pyx:45:5: Exception check on '_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_axpy' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:58:5: Exception check on '_nrm2' will always require the GIL to be acquired. Declare '_nrm2' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_cython_blas.pyx:70:5: Exception check on '_copy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_copy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_copy' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:82:5: Exception check on '_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_scal' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:94:5: Exception check on '_rotg' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_rotg' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_rotg' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:107:5: Exception check on '_rot' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_rot' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_rot' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:124:5: Exception check on '_gemv' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_gemv' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_gemv' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:153:5: Exception check on '_ger' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_ger' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_ger' to allow an error code to be returned.
      performance hint: sklearn/utils/_cython_blas.pyx:183:5: Exception check on '_gemm' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_gemm' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_gemm' to allow an error code to be returned.
      
      Error compiling Cython file:
      ------------------------------------------------------------
      ...
              dec(end)
              # Construct our arguments
              cdef pair[ITYPE_t, DTYPE_t] args
              args.first = key
              args.second = value
              self.my_map.insert(end, args)
                                 ^
      ------------------------------------------------------------
      
      sklearn/utils/_fast_dict.pyx:136:27: Cannot assign type 'iterator' to 'const_iterator'
      Traceback (most recent call last):
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/utils/_fast_dict.pyx
      warning: sklearn/utils/_openmp_helpers.pyx:1:0: The 'IF' statement is deprecated and will be removed in a future Cython version. Consider using runtime conditions or C macros instead. See https://github.com/cython/cython/issues/4310
      warning: sklearn/utils/_openmp_helpers.pyx:44:4: The 'IF' statement is deprecated and will be removed in a future Cython version. Consider using runtime conditions or C macros instead. See https://github.com/cython/cython/issues/4310
      performance hint: sklearn/utils/_seq_dataset.pyx:77:53: Exception check after calling '_get_next_index' will always require the GIL to be acquired. Declare '_get_next_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_seq_dataset.pyx:78:20: Exception check after calling '_sample' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_sample' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_sample' to allow an error code to be returned.
      performance hint: sklearn/utils/_seq_dataset.pyx:114:55: Exception check after calling '_get_random_index' will always require the GIL to be acquired. Declare '_get_random_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_seq_dataset.pyx:115:20: Exception check after calling '_sample' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_sample' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_sample' to allow an error code to be returned.
      performance hint: sklearn/utils/_seq_dataset.pyx:402:53: Exception check after calling '_get_next_index' will always require the GIL to be acquired. Declare '_get_next_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_seq_dataset.pyx:403:20: Exception check after calling '_sample' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_sample' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_sample' to allow an error code to be returned.
      performance hint: sklearn/utils/_seq_dataset.pyx:439:55: Exception check after calling '_get_random_index' will always require the GIL to be acquired. Declare '_get_random_index' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
      performance hint: sklearn/utils/_seq_dataset.pyx:440:20: Exception check after calling '_sample' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '_sample' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '_sample' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:178:29: Exception check after calling 'reset_wscale' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'reset_wscale' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'reset_wscale' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:183:17: Exception check after calling '__pyx_fuse_1_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_axpy' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:185:17: Exception check after calling '__pyx_fuse_1_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_scal' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:189:13: Exception check after calling '__pyx_fuse_1_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_1_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_1_scal' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:351:29: Exception check after calling 'reset_wscale' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare 'reset_wscale' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on 'reset_wscale' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:356:17: Exception check after calling '__pyx_fuse_0_axpy' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_axpy' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_axpy' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:358:17: Exception check after calling '__pyx_fuse_0_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_scal' to allow an error code to be returned.
      performance hint: sklearn/utils/_weight_vector.pyx:362:13: Exception check after calling '__pyx_fuse_0_scal' will always require the GIL to be acquired.
      Possible solutions:
          1. Declare '__pyx_fuse_0_scal' as 'noexcept' if you control the definition and you're sure you don't want the function to raise exceptions.
          2. Use an 'int' return type on '__pyx_fuse_0_scal' to allow an error code to be returned.
      multiprocessing.pool.RemoteTraceback:
      """
      Traceback (most recent call last):
        File "/usr/lib/python3.11/multiprocessing/pool.py", line 125, in worker
          result = (True, func(*args, **kwds))
                          ^^^^^^^^^^^^^^^^^^^
        File "/usr/lib/python3.11/multiprocessing/pool.py", line 48, in mapstar
          return list(map(*args))
                 ^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1345, in cythonize_one_helper
          return cythonize_one(*m)
                 ^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1321, in cythonize_one
          raise CompileError(None, pyx_file)
      Cython.Compiler.Errors.CompileError: sklearn/ensemble/_hist_gradient_boosting/splitting.pyx
      """
      
      The above exception was the direct cause of the following exception:
      
      Traceback (most recent call last):
        File "/workspaces/internshala-automation/venv/lib/python3.11/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py", line 389, in <module>
      [ 1/55] Cythonizing sklearn/__check_build/_check_build.pyx
      [ 2/55] Cythonizing sklearn/_isotonic.pyx
      [ 3/55] Cythonizing sklearn/cluster/_dbscan_inner.pyx
      [ 4/55] Cythonizing sklearn/cluster/_hierarchical_fast.pyx
      [ 5/55] Cythonizing sklearn/cluster/_k_means_common.pyx
      [ 6/55] Cythonizing sklearn/cluster/_k_means_elkan.pyx
      [ 7/55] Cythonizing sklearn/cluster/_k_means_lloyd.pyx
      [ 8/55] Cythonizing sklearn/cluster/_k_means_minibatch.pyx
      [ 9/55] Cythonizing sklearn/datasets/_svmlight_format_fast.pyx
      [10/55] Cythonizing sklearn/decomposition/_cdnmf_fast.pyx
      [11/55] Cythonizing sklearn/decomposition/_online_lda_fast.pyx
      [12/55] Cythonizing sklearn/ensemble/_gradient_boosting.pyx
      [13/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/_binning.pyx
      [14/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/_bitset.pyx
      [15/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/_gradient_boosting.pyx
      [16/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/_loss.pyx
      [17/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/_predictor.pyx
      [18/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/common.pyx
      [19/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/histogram.pyx
      [20/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/splitting.pyx
      [21/55] Cythonizing sklearn/ensemble/_hist_gradient_boosting/utils.pyx
      [22/55] Cythonizing sklearn/feature_extraction/_hashing_fast.pyx
      [23/55] Cythonizing sklearn/linear_model/_cd_fast.pyx
      [24/55] Cythonizing sklearn/linear_model/_sag_fast.pyx
      [25/55] Cythonizing sklearn/linear_model/_sgd_fast.pyx
      [26/55] Cythonizing sklearn/manifold/_barnes_hut_tsne.pyx
      [27/55] Cythonizing sklearn/manifold/_utils.pyx
      [28/55] Cythonizing sklearn/metrics/_dist_metrics.pyx
      [29/55] Cythonizing sklearn/metrics/_pairwise_fast.pyx
      [30/55] Cythonizing sklearn/metrics/cluster/_expected_mutual_info_fast.pyx
      [31/55] Cythonizing sklearn/neighbors/_ball_tree.pyx
      [32/55] Cythonizing sklearn/neighbors/_kd_tree.pyx
      [33/55] Cythonizing sklearn/neighbors/_partition_nodes.pyx
      [34/55] Cythonizing sklearn/neighbors/_quad_tree.pyx
      [35/55] Cythonizing sklearn/preprocessing/_csr_polynomial_expansion.pyx
      [36/55] Cythonizing sklearn/svm/_liblinear.pyx
      [37/55] Cythonizing sklearn/svm/_libsvm.pyx
      [38/55] Cythonizing sklearn/svm/_libsvm_sparse.pyx
      [39/55] Cythonizing sklearn/svm/_newrand.pyx
      [40/55] Cythonizing sklearn/tree/_criterion.pyx
      [41/55] Cythonizing sklearn/tree/_splitter.pyx
      [42/55] Cythonizing sklearn/tree/_tree.pyx
      [43/55] Cythonizing sklearn/tree/_utils.pyx
      [44/55] Cythonizing sklearn/utils/_cython_blas.pyx
      [45/55] Cythonizing sklearn/utils/_fast_dict.pyx
      [46/55] Cythonizing sklearn/utils/_logistic_sigmoid.pyx
      [47/55] Cythonizing sklearn/utils/_openmp_helpers.pyx
      [48/55] Cythonizing sklearn/utils/_random.pyx
      [49/55] Cythonizing sklearn/utils/_readonly_array_wrapper.pyx
      [50/55] Cythonizing sklearn/utils/_seq_dataset.pyx
      [51/55] Cythonizing sklearn/utils/_typedefs.pyx
      [52/55] Cythonizing sklearn/utils/_weight_vector.pyx
      [53/55] Cythonizing sklearn/utils/arrayfuncs.pyx
      [54/55] Cythonizing sklearn/utils/murmurhash.pyx
      [55/55] Cythonizing sklearn/utils/sparsefuncs_fast.pyx
          main()
        File "/workspaces/internshala-automation/venv/lib/python3.11/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py", line 373, in main
          json_out["return_val"] = hook(**hook_input["kwargs"])
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        File "/workspaces/internshala-automation/venv/lib/python3.11/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py", line 175, in prepare_metadata_for_build_wheel
          return hook(metadata_directory, config_settings)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/setuptools/build_meta.py", line 174, in prepare_metadata_for_build_wheel
          self.run_setup()
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/setuptools/build_meta.py", line 268, in run_setup
          self).run_setup(setup_script=setup_script)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/setuptools/build_meta.py", line 158, in run_setup
          exec(compile(code, __file__, 'exec'), locals())
        File "setup.py", line 319, in <module>
          setup_package()
        File "setup.py", line 315, in setup_package
          setup(**metadata)
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/numpy/distutils/core.py", line 135, in setup
          config = configuration()
                   ^^^^^^^^^^^^^^^
        File "setup.py", line 201, in configuration
          config.add_subpackage("sklearn")
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/numpy/distutils/misc_util.py", line 1050, in add_subpackage
          config_list = self.get_subpackage(subpackage_name, subpackage_path,
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/numpy/distutils/misc_util.py", line 1016, in get_subpackage
          config = self._get_configuration_from_setup_py(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/numpy/distutils/misc_util.py", line 958, in _get_configuration_from_setup_py
          config = setup_module.configuration(*args)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        File "/tmp/pip-install-fzbuymap/scikit-learn_73692ed8333948ea91a2c70460f146eb/sklearn/setup.py", line 85, in configuration
          cythonize_extensions(top_path, config)
        File "/tmp/pip-install-fzbuymap/scikit-learn_73692ed8333948ea91a2c70460f146eb/sklearn/_build_utils/__init__.py", line 78, in cythonize_extensions
          config.ext_modules = cythonize(
                               ^^^^^^^^^^
        File "/tmp/pip-build-env-s8wjbhiv/overlay/lib/python3.11/site-packages/Cython/Build/Dependencies.py", line 1145, in cythonize
          result.get(99999)  # seconds
          ^^^^^^^^^^^^^^^^^
        File "/usr/lib/python3.11/multiprocessing/pool.py", line 774, in get
          raise self._value
      Cython.Compiler.Errors.CompileError: sklearn/ensemble/_hist_gradient_boosting/splitting.pyx
      [end of output]
  
  note: This error originates from a subprocess, and is likely not a problem with pip.
error: metadata-generation-failed

× Encountered error while generating package metadata.
╰─> See above for output.

note: This is an issue with the package mentioned above, not pip.
hint: See above for details.
